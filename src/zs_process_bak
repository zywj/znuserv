
#include <zs_core.h>

static long timeout;

static char *rn = "\r\n";
static int_t epfd;
struct epoll_event ee;
zs_request_t reqs[ZS_MAX_REQ];
zs_process_t process[ZS_MAX_PROCESS];

zs_request_t * 
zs_get_req_slow(sock_t sockfd)
{
	int i;

	for (i = 1; i < ZS_MAX_REQ; i++) {
		if (reqs[i].fd == sockfd) {
			return &reqs[i];
		}  
	}
	
	return 0;
}

zs_request_t *
zs_get_empty_req(sock_t sockfd)
{
	if (sockfd < ZS_MAX_REQ &&
			sockfd >= 0 && reqs[sockfd].fd == -1) {
		return &reqs[sockfd]; 

	} else {
		return zs_get_req_slow(-1); 
	}
}

zs_request_t *
zs_get_req(sock_t sockfd)
{
	if (sockfd < ZS_MAX_REQ && 
			sockfd >= 0 && reqs[sockfd].fd == sockfd) {
		return &reqs[sockfd];
	} else {
		return zs_get_req_slow(sockfd); 
	}
}

void 
zs_send_header(sock_t sockfd)
{
	zs_request_t *req;
	int n, len;

	req = zs_get_req(sockfd);
	req->res_header = zs_palloc(req->pool, 256);

	switch (req->res_code) {
	
	case 404:
		req->res_header = ZS_404_header;
		break;

	case 400:
		req->res_header = ZS_400_header;
		break;

	case 200:
		req->res_header = ZS_200_header;
		break;
	}

	len = strlen(req->res_header);
	req->has_written = 0;

	while (len != req->has_written) {
		n = write(sockfd, req->res_header + req->has_written, len - req->has_written);

		if (n == -1) {
			if (errno == EAGAIN) {
				break;

			} else {
				return;
			}

		} else if (n == 0) {
			zs_err("sending header. Client close.\n");
			return ;

		} else if (n > 0) {
			req->has_written += n;
		}
	}

	req->status = ZS_WR_REQ;

	ee.events = EPOLLOUT | EPOLLET;
	ee.data.fd = sockfd;
	epoll_ctl(epfd, EPOLL_CTL_MOD, sockfd, &ee);
}

void 
zs_read_php(zs_context_t *ctx, sock_t sockfd)
{    
	zs_request_t *req, *req2;
	int n;

	req = zs_get_req(sockfd);
	req2 = zs_get_req(req->file_fd);

	req2->res_cnt = zs_palloc(req2->pool, 70000);
	req2->has_read = 0;
	while (1) {
		n = read(sockfd, req2->res_cnt + req2->has_read, 70000 - req2->has_read);

		if (n < 0) {
			if (errno == EAGAIN) {
				break;
			
			} else {
				return;
			} 

		} else if (n == 0) {
			return ;

		} else if (n > 0) {
			req2->has_read += n;
		}
	}

	req2->res_length = strlen(req2->res_cnt);
	ee.events = EPOLLOUT | EPOLLET;
	ee.data.fd = req->file_fd;
	epoll_ctl(epfd, EPOLL_CTL_MOD, req->file_fd, &ee);

	epoll_ctl(epfd, EPOLL_CTL_DEL, sockfd, &ee);
	req->fd = -1;
	req2->status = ZS_WR_PHP;
}

void
zs_send_php(zs_context_t *ctx, sock_t sockfd) 
{
	zs_request_t *req;
	int n;

	req = zs_get_req(sockfd);

	req->has_written = 0;
	while (req->res_length != req->has_written) {
		n = write(sockfd, req->res_cnt, req->res_length - req->has_written);

		if (n < 0) {
			if (errno == EAGAIN) {
				break;

			} else {
				return;
			}

		} else {
			req->has_written += n;
		}
	}

	epoll_ctl(epfd, EPOLL_CTL_DEL, sockfd, &ee);

	close(req->fd);
	req->fd = -1;

	zs_pfree(req->pool, req->res_cnt);
	zs_destroy_pool(req->pool);
}

void 
zs_write_req_php(zs_context_t *ctx, sock_t sockfd)
{
	int len, n;
	zs_request_t *req, *req2;

	req = zs_get_req(sockfd);
	req2 = zs_get_req(req->file_fd);

	//向apache写入请求
	len = strlen(req2->buf);
	req->has_written = 0;

	while (len != req->has_written) {
	   n = write(sockfd, req2->buf + req->has_written, len - req->has_written); 

	   if (n < 0) {
			if (errno == EAGAIN) {
				break;

			} else {
				return  ;
			}

	   } else {
			req->has_written += n;
	   }
	}

	ee.events = EPOLLIN | EPOLLET;
	ee.data.fd = sockfd;
	n = epoll_ctl(epfd, EPOLL_CTL_MOD, sockfd, &ee); 

	if (n < 0) {
		zs_err("epoll add apache fd failed.\n");
	}

	req->status = ZS_RD_PHP;
}

int_t 
zs_send_req_to_apache(zs_context_t *ctx, sock_t sockfd)
{
	int_t n, php_listen_port;
	zs_request_t *req, *newreq;
	sock_t fd;
	struct sockaddr_in addr;

	req = zs_get_req(sockfd);
	req->is_php = 1;

	php_listen_port = ctx->conf->php_listen_port;

	fd = socket(AF_INET, SOCK_STREAM, 0);
	bzero(&addr, sizeof(addr));
	addr.sin_family = AF_INET;
	addr.sin_port = htons(php_listen_port);
	
	//连接apache监听端口
	n = connect(fd, (struct sockaddr *) &addr, sizeof(addr));
	if (n == -1) {
		zs_err("connect to apache listen port failed.\n"); 

		return ZS_ERR;
	}
	
	zs_set_nonblocking(fd);

	ee.events = EPOLLOUT | EPOLLET;
	ee.data.fd = fd;
	epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &ee);

	newreq = zs_get_empty_req(fd);
	newreq->pool = zs_create_pool(ZS_REQ_MAX_POOL);
	newreq->has_read = 0;
	newreq->has_written = 0;
	newreq->status = ZS_WR_REQ_PHP;
	newreq->fd = fd;
	newreq->file_fd = sockfd;

	return ZS_OK;
}

void 
zs_get_request_line(zs_context_t *ctx, sock_t sockfd)
{
	int i;
	char *p;
	zs_request_t *req;

	req = zs_get_req(sockfd);

	p = zs_palloc(req->pool, 64);
	i = strcspn(req->buf, rn);
	strncpy(p, req->buf, i);

	req->request_method = zs_palloc(req->pool, 256);
	req->uri = zs_palloc(req->pool, 256);
	req->http_version = zs_palloc(req->pool, 256);

	//获取请求行
	sscanf(p, "%s %s %s", req->request_method, req->uri, req->http_version);
	req->http_version[8] = '\0';
	
	//获取请求文件后缀
	req->suffix = strrchr(req->uri, '.');
}

char *
zs_add_index_file(zs_context_t *ctx, sock_t sockfd) 
{
	int i;
	FILE *fp;
	char *pf, *root_dir, *idf;
	zs_request_t *req;

	req = zs_get_req(sockfd);

	root_dir = zs_palloc(ctx->pool, 256);
	root_dir = ctx->conf->root_dir;
	root_dir[strlen(root_dir)] = '/';

	for (i = 0; i < ZS_MAX_REQ; i++) { 
		//先把路径+请求文件合并，尝试打开首页文件
		pf = zs_palloc(req->pool, 1024);
		strcpy(pf, root_dir); 
		strncpy(pf + strlen(root_dir), ctx->conf->index_files[i], strlen(ctx->conf->index_files[i]));

		fp = fopen(pf, "r"); 
		if (fp != NULL) {
			idf = zs_palloc(ctx->pool, 256);
			strcpy(idf, "/"); 
			strncpy(idf + 1, ctx->conf->index_files[i], strlen(ctx->conf->index_files[i]));
			req->suffix = strrchr(idf, '.');

			return  idf;
		} 
	} 

	//如果没有找到首页文件
	if (fp == NULL) {
		zs_err("index not found.\n");     
	}

	return 0;
}

int_t 
zs_run_get_method(zs_context_t *ctx, sock_t sockfd)
{
	char *query, *pf,*root_dir;
	zs_request_t *req;
	int n;

	req = zs_get_req(sockfd);

	query = zs_palloc(req->pool, 256);
	root_dir = zs_palloc(req->pool, 256);
	pf = zs_palloc(req->pool, 1024);

	/* 自动添加首页文件 */
	if (req->uri[0] == '/' && strlen(req->uri) == 1) {
		query = zs_add_index_file(ctx, sockfd); 

	} else {
		query = req->uri; 
	}

	root_dir = ctx->conf->root_dir;
	
	/* 把站点目录与请求页面的请求字符串合并 */
	strncpy(pf, root_dir, strlen(root_dir)); 
	strncpy(pf + strlen(root_dir), query, strlen(query));
	req->pf = zs_palloc(req->pool, 1024);
	req->pf = pf;

	//判断是否是php文件
	if (req->suffix[strlen(req->suffix) - 1] == 'p') {
		if (zs_send_req_to_apache(ctx, sockfd) != ZS_OK) {
			return ZS_ERR; 
		}

	} else {
		if ((req->file_fd = open(req->pf, O_RDONLY)) == -1) {
			req->res_code = 404; 

		} else {
			req->res_code = 200;     

			/* read event end, start write event */
			req->status = ZS_WR_HEADER;
		}

		ee.events = EPOLLOUT | EPOLLET;
		ee.data.fd = sockfd;
		n = epoll_ctl(epfd, EPOLL_CTL_MOD, sockfd, &ee);

		if (n == -1) {
			zs_err("epoll modify error."); 
		}
	}

	return ZS_OK;
}

void 
zs_parse_start(zs_context_t *ctx, sock_t sockfd)
{
	int n;
	zs_request_t *req;

	req = zs_get_req(sockfd);

	//如果是GET 
	if (req->request_method[0] == 'G') {

		//执行GET操作
		n = zs_run_get_method(ctx, sockfd); 
		
		//如果找不到请求文件
		if (n == ZS_NO) {
			return; 
		}
	}
}

void 
zs_parse_request(zs_context_t *ctx, sock_t sockfd)
{
	//获取请求行
	zs_get_request_line(ctx, sockfd);

	//开始分析请求行
	zs_parse_start(ctx, sockfd);
}

void
zs_read_request(zs_context_t *ctx, sock_t sockfd)
{
	zs_request_t *req;
	int_t n;

	req = zs_get_req(sockfd);

	while (1) {
		n = read(sockfd, req->buf + req->has_read, ZS_READ_MAX - req->has_read);         

		if (n == -1) {
			if ((errno == EAGAIN) || (errno == EWOULDBLOCK)) {
				break;

			} else {
				return;
			}

		} else  if (n == 0) {
			return; 

		} else if (n > 0) {
			req->has_read += n; 
		}
	}
	
	/* start parse the request */
	zs_parse_request(ctx, sockfd);

}

void
zs_send_response(zs_context_t *ctx, sock_t sockfd)
{
	zs_request_t *req;
	int_t n;
	off_t offset;
	struct stat buf;

	req = zs_get_req(sockfd);
	req->has_written = 0;

	fstat(req->file_fd, &buf);
	req->res_length = buf.st_size;  

	while (1) {
		offset = req->has_written;
		n = sendfile(req->fd, req->file_fd, &offset, 4094 - req->has_written); 
		req->has_written = offset; 

		if (n < 0) {
			if (errno == EAGAIN) {
				break; 

			} else {
				return ; 
			}
		} 

		if (req->has_written == req->res_length) {
			int on = 0;
			n = epoll_ctl(epfd, EPOLL_CTL_DEL, sockfd, &ee);
			if (n < 0) {
				zs_err("epoll ctl del failed.\n");
			}
			setsockopt(req->fd, SOL_TCP, TCP_CORK, &on, sizeof(on));
			close(req->fd);
			req->fd = -1;
			//zs_destroy_pool(req->pool);

			req->status = -1;
			break;
		}
	}  
}

void 
zs_handle_request(zs_context_t *ctx, sock_t sockfd, int i)
{
	int_t n, on = 1;
	sock_t connfd, listenfd;
	zs_request_t *req, *newreq;
	struct sockaddr_in cliaddr;
	socklen_t socklen;

	listenfd = ctx->listen_sock.sockfd;    

	if (listenfd == sockfd ) {

		zs_err("conn num: %d\n", process[i].connection_num);
		if (process[i].connection_num < ctx->conf->worker_connections / 2) {		
			while (1) {
				socklen = sizeof(cliaddr);
				connfd = accept(listenfd, (struct sockaddr *)&cliaddr, &socklen);         

				if (connfd == -1) {
					if ((errno == EAGAIN) || (errno == EWOULDBLOCK))  {
						break; 

					} else {
						zs_err("accept error.\n");     
						break;
					}
				}
		
				process[i].connection_num++;
				zs_err("pid: %d, conn_num:%d, sock: %d\n", process[i].pid, process[i].connection_num, connfd);

				n = zs_set_nonblocking(connfd);
				if  (n == -1) {
					return ; 
				}

				setsockopt(connfd, SOL_TCP, TCP_CORK, &on, sizeof(on));

				newreq = zs_get_empty_req(connfd);
				newreq->pool = zs_create_pool(ZS_REQ_MAX_POOL);
				newreq->fd = connfd;
				newreq->status = ZS_RD_REQ;
				newreq->has_read = 0;
				newreq->has_written = 0;
				newreq->process = process[i];
				ee.data.fd = connfd;
				ee.events = EPOLLIN | EPOLLET;
				n = epoll_ctl(epfd, EPOLL_CTL_ADD, connfd, &ee);

				if (n == -1) {
					zs_err("connfd epoll add failed.\n"); 
					return;
				}
			}	
		}

	} else {	
		req = zs_get_req(sockfd);
		req->process = process[i];

		switch (req->status) {

		case ZS_RD_REQ:  
			zs_read_request(ctx, sockfd);
			break;

		case ZS_WR_HEADER:
			zs_send_header(sockfd);    
			break;

		case ZS_WR_REQ:
			zs_send_response(ctx, sockfd);
			break;

		case ZS_RD_PHP:
			zs_read_php(ctx, sockfd);
			break;

		case ZS_WR_PHP:
			zs_send_php(ctx, sockfd);
			break;

		case ZS_WR_REQ_PHP:
			zs_write_req_php(ctx, sockfd);
			break;
		}
	}
}

void 
zs_worker_process_init(zs_context_t *ctx)
{
	struct rlimit rl;
	int i;

	rl.rlim_cur = (rlim_t)((2 << 15) - 1);
	rl.rlim_max = (rlim_t)((2 << 15) - 1);

	if (setrlimit(RLIMIT_NOFILE, &rl) != 0) {
		zs_err("set resource limit error.\n"); 
	}

	timeout = ctx->conf->event_timeout * 100;

	/* initialize the requests */
	for (i = 0; i < 1024; i++) {
		reqs[i].fd = -1;
	}
}

static int_t
zs_process_event(zs_context_t *ctx, int i)
{
	int_t nevents, k;  
	sock_t listenfd, sockfd;
	struct epoll_event elist[ZS_MAXEVENT], ee; 

	listenfd = ctx->listen_sock.sockfd;

	epfd = epoll_create(1);
	
	if (epfd < 0) {
		zs_err("epoll create failed.\n"); 
		return ZS_ERR;
	}

	ee.data.fd = listenfd;
	ee.events = EPOLLIN | EPOLLET;
	epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &ee);

	do {
		nevents = epoll_wait(epfd, elist, ZS_MAXEVENT, 400);                
		if (nevents < 0) {
			zs_err("epoll wait failed.\n"); 
			return ZS_ERR;
		}
		
		for (k = 0; k < nevents; k++) { 
			if ((elist[k].events & EPOLLERR) ||
					(elist[k].events & EPOLLHUP)) {
				zs_err("epoll error.\n");
				close(elist[k].data.fd);
				continue;
			}

			sockfd = elist[k].data.fd;

			zs_handle_request(ctx, sockfd, i);
		}

	} while(1);
}

static void
zs_worker_process_loop(zs_context_t *ctx, int i)
{
	zs_worker_process_init(ctx);
	
	for ( ; ; ) {
	   if (zs_process_event(ctx, i) < 0) {
		   zs_err("process event failed.\n");      
		   return;
	   }       

		/*worker processes receive signal...*/
	}
}

static void
zs_spawn_worker_process(zs_context_t *ctx, int i)
{
	pid_t  pid;

	pid = fork();

	switch(pid) {
		
	case -1:
		zs_err("worker process fork error.\n");
		return ;

	case 0:
		process[i].pid = getpid();
		zs_worker_process_loop(ctx, i);
		break;
	
	default: 
		break;
	}
}

void 
zs_worker_process(zs_context_t *ctx)
{
	int_t i, num_workers;
	
	num_workers = ctx->conf->workers;

	for (i = 0; i < num_workers; i++) {
	   zs_spawn_worker_process(ctx, i);  
	}
}

void 
zs_master_process(zs_context_t *ctx)
{
	sigset_t sigset, mset;

	/*
	 * Blocking some signals.
	 */
	sigemptyset(&sigset);
	sigaddset(&sigset, SIGCHLD);
	sigaddset(&sigset, SIGHUP);
	//sigaddset(&sigset, SIGINT);
	sigaddset(&sigset, SIGTERM);
	sigaddset(&sigset, SIGALRM);

	if (sigprocmask(SIG_BLOCK, &sigset, NULL) == -1) {
		zs_err("sigprocmask error.\n"); 
	}

	if (zs_listen(ctx) == ZS_ERR) {
		zs_err("master process listen error.\n"); 
	}

	/* start worker process */
	zs_worker_process(ctx);

	/*
	 * Master process suspend....
	 */
	for (;;) {
		sigsuspend(&mset);
	}
}

